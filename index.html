<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S7eps_</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        .track-row { transition: box-shadow 0.2s ease-out; }
        .track-row.selected { box-shadow: 0 0 15px rgba(59, 130, 246, 0.6); background-color: rgba(59, 130, 246, 0.1); border-radius: 0.5rem; }
        .step { transition: all 0.1s ease-in-out; border: 1px solid #374151; }
        .step.accent { background-color: #4b5563; }
        .step:not(.accent) { background-color: #374151; }
        .step:hover { background-color: #556173; }
        .step.active { background-color: #4299e1; transform: scale(1.05); box-shadow: 0 0 10px rgba(66, 153, 225, 0.4); }
        .step.current { background-color: #f59e0b; border-color: #f59e0b; }
        .step.active.current { background-color: #63b3ed; box-shadow: 0 0 15px rgba(245, 158, 11, 0.7); }
        .step.next-record-step {
            border-color: #fbbf24; /* amber-400 */
            box-shadow: 0 0 12px rgba(251, 191, 36, 0.6);
        }
        .modal { transition: opacity 0.25s ease; }
        .modal.hidden { opacity: 0; pointer-events: none; }
        #sequencer-grid-wrapper::-webkit-scrollbar, #note-input-scroll-wrapper::-webkit-scrollbar, .modal-scroll-content::-webkit-scrollbar { height: 8px; width: 8px; }
        #sequencer-grid-wrapper::-webkit-scrollbar-track, #note-input-scroll-wrapper::-webkit-scrollbar-track, .modal-scroll-content::-webkit-scrollbar-track { background: #1f2937; }
        #sequencer-grid-wrapper::-webkit-scrollbar-thumb, #note-input-scroll-wrapper::-webkit-scrollbar-thumb, .modal-scroll-content::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        #sequencer-grid-wrapper::-webkit-scrollbar-thumb:hover, #note-input-scroll-wrapper::-webkit-scrollbar-thumb:hover, .modal-scroll-content::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .arm-btn.armed { background-color: #e11d48; color: white; box-shadow: 0 0 10px rgba(225, 29, 72, 0.7); }
        
        .note-input-btn { background-color: #374151; border: 1px solid #1f2937; color: #d1d5db; transition: background-color 0.1s ease; }
        .note-input-btn.sharp { background-color: #111827; }
        .note-input-btn:active, .note-input-btn.pressed { background-color: #60a5fa; color: #111827; }
        
        .toggle-btn { padding: 0.25rem 0.75rem; border-radius: 0.375rem; border: 1px solid #4b5563; cursor: pointer; transition: all 0.1s; }
        .toggle-btn.active { background-color: #2563eb; border-color: #2563eb; color: white; }
        .mute-btn.muted { background-color: #f59e0b; color: white; }
        .solo-btn.soloed { background-color: #16a34a; color: white; }

        /* Glitch Logo Styles */
        .glitch-logo {
            font-size: 2.25rem; /* Equivalent to text-3xl */
            font-weight: 700;
            color: #fff;
            position: relative;
            letter-spacing: 0.05em;
            animation: glitch-skew 1s infinite linear alternate-reverse;
        }

        .glitch-logo::before,
        .glitch-logo::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1f2937; /* Match body background */
            overflow: hidden;
        }

        .glitch-logo::before {
            left: 2px;
            text-shadow: -2px 0 #ff00c1;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim 5s infinite linear alternate-reverse;
        }

        .glitch-logo::after {
            left: -2px;
            text-shadow: -2px 0 #00fff9, 2px 2px #ff00c1;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim2 5s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim {
            0% { clip: rect(42px, 9999px, 44px, 0); } 5% { clip: rect(17px, 9999px, 96px, 0); } 10% { clip: rect(50px, 9999px, 62px, 0); } 15% { clip: rect(27px, 9999px, 68px, 0); } 20% { clip: rect(67px, 9999px, 81px, 0); } 25% { clip: rect(32px, 9999px, 53px, 0); } 30% { clip: rect(81px, 9999px, 51px, 0); } 35% { clip: rect(43px, 9999px, 92px, 0); } 40% { clip: rect(88px, 9999px, 3px, 0); } 45% { clip: rect(49px, 9999px, 73px, 0); } 50% { clip: rect(1px, 9999px, 66px, 0); } 55% { clip: rect(55px, 9999px, 2px, 0); } 60% { clip: rect(25px, 9999px, 83px, 0); } 65% { clip: rect(78px, 9999px, 49px, 0); } 70% { clip: rect(40px, 9999px, 19px, 0); } 75% { clip: rect(35px, 9999px, 78px, 0); } 80% { clip: rect(69px, 9999px, 55px, 0); } 85% { clip: rect(10px, 9999px, 37px, 0); } 90% { clip: rect(74px, 9999px, 60px, 0); } 95% { clip: rect(26px, 9999px, 3px, 0); } 100% { clip: rect(5px, 9999px, 85px, 0); }
        }

        @keyframes glitch-anim2 {
             0% { clip: rect(63px, 9999px, 13px, 0); } 5% { clip: rect(2px, 9999px, 73px, 0); } 10% { clip: rect(91px, 9999px, 82px, 0); } 15% { clip: rect(5px, 9999px, 29px, 0); } 20% { clip: rect(24px, 9999px, 100px, 0); } 25% { clip: rect(88px, 9999px, 40px, 0); } 30% { clip: rect(4px, 9999px, 74px, 0); } 35% { clip: rect(45px, 9999px, 58px, 0); } 40% { clip: rect(80px, 9999px, 45px, 0); } 45% { clip: rect(26px, 9999px, 97px, 0); } 50% { clip: rect(93px, 9999px, 9px, 0); } 55% { clip: rect(27px, 9999px, 61px, 0); } 60% { clip: rect(9px, 9999px, 40px, 0); } 65% { clip: rect(3px, 9999px, 62px, 0); } 70% { clip: rect(53px, 9999px, 38px, 0); } 75% { clip: rect(33px, 9999px, 17px, 0); } 80% { clip: rect(48px, 9999px, 79px, 0); } 85% { clip: rect(46px, 9999px, 98px, 0); } 90% { clip: rect(97px, 9999px, 19px, 0); } 95% { clip: rect(38px, 9999px, 33px, 0); } 100% { clip: rect(8px, 9999px, 47px, 0); }
        }
        
        @keyframes glitch-skew {
          0% { transform: skewX(0); } 5% { transform: skewX(2deg); } 10% { transform: skewX(-1.5deg); } 15% { transform: skewX(0.8deg); } 20% { transform: skewX(0); } 100% { transform: skewX(0); }
        }

    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div id="sequencer-container" class="bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-2xl w-full max-w-7xl flex flex-col space-y-4 border border-gray-700 h-[95vh]">
        
        <header class="flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 flex-shrink-0">
            <h1 class="glitch-logo" data-text="S7eps_">S7eps_</h1>
            <div class="flex items-center flex-wrap justify-center gap-4">
                <div class="flex items-center space-x-2">
                     <button id="remove-track-btn" class="bg-red-800 hover:bg-red-700 text-white font-bold p-2 rounded-lg">- Track</button>
                     <button id="add-track-btn" class="bg-green-700 hover:bg-green-600 text-white font-bold p-2 rounded-lg">+ Track</button>
                </div>
                <button id="midi-settings-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">MIDI I/O</button>
                 <div class="flex items-center space-x-2">
                    <label for="clock-source-select" class="font-medium">Clock</label>
                    <select id="clock-source-select" class="bg-gray-600 rounded p-2 text-sm">
                        <option value="internal">Internal</option>
                    </select>
                </div>
                <div class="flex items-center space-x-3">
                    <label for="tempo-slider" class="font-medium">BPM</label>
                    <input type="range" id="tempo-slider" min="60" max="240" value="120" class="w-24 sm:w-32">
                    <span id="tempo-display" class="font-mono bg-gray-700 px-2 py-1 rounded-md text-sm">120</span>
                </div>
                <button id="play-stop-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg">Play</button>
            </div>
        </header>
        
        <div id="playhead-controls" class="flex-shrink-0 w-full flex justify-center items-center gap-4 py-1 hidden">
             <button id="playhead-left-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded-lg text-lg">&larr;</button>
             <span class="text-xs text-gray-400">STEP RECORD</span>
             <button id="playhead-right-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded-lg text-lg">&rarr;</button>
        </div>

        <div id="note-input-scroll-wrapper" class="flex-shrink-0 w-full overflow-x-auto bg-gray-700 rounded-lg p-2">
             <div id="note-input-grid" class="h-20 grid grid-rows-2 grid-flow-col gap-1" style="min-width: 105rem;"></div>
        </div>

        <div id="sequencer-grid-wrapper" class="flex-grow overflow-y-auto pr-2">
            <main id="sequencer-grid" class="space-y-4"></main>
        </div>
    </div>
    
    <div id="modals-container">
        <!-- Modals will be rendered here by JS -->
    </div>

    <script type="module">
        // --- CONSTANTS ---
        const NUM_STEPS = 16;
        const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const NOTE_INPUT_OCTAVES = 7;
        const NOTE_INPUT_START_OCTAVE = 1;
        const CLOCK_INTERVAL_BUFFER_SIZE = 48; // For smoothing MIDI clock
        const SYNTH_ALGORITHMS = {
            'VA': 'Virtual Analog',
            'FM': 'FM',
            'Pluck': 'Plucked String',
            'Wavefolder': 'Wavefolder'
        };
        
        // --- DOM ELEMENT CACHE ---
        const dom = {
            gridContainer: document.getElementById('sequencer-grid'),
            playStopBtn: document.getElementById('play-stop-btn'),
            tempoSlider: document.getElementById('tempo-slider'),
            tempoDisplay: document.getElementById('tempo-display'),
            noteInputGrid: document.getElementById('note-input-grid'),
            modalsContainer: document.getElementById('modals-container'),
            addTrackBtn: document.getElementById('add-track-btn'),
            removeTrackBtn: document.getElementById('remove-track-btn'),
            midiSettingsBtn: document.getElementById('midi-settings-btn'),
            clockSourceSelect: document.getElementById('clock-source-select'),
            playheadControls: document.getElementById('playhead-controls'),
        };

        // --- APPLICATION STATE ---
        const state = {
            tracks: [],
            stepGrid: [],
            nonPlayStepIndices: [],
            isPlaying: false,
            currentStep: -1,
            armedTrackIndex: -1,
            selectedTrackIndex: 0,
            soloedTrackIndex: -1,
            activeModalTrackIndex: -1,
            activeModalStep: null,
            liveNotes: new Set(),
            listenersInitialized: false,
            midi: {
                access: null,
                inputs: [],
                outputs: [],
                clockSourceId: 'internal',
                lastClockTime: 0,
                clockIntervals: [],
            }
        };
        
        // --- UTILITY FUNCTIONS ---
        function midiToNoteName(midi) {
            return NOTE_NAMES[midi % 12] + (Math.floor(midi / 12) - 1);
        }

        function noteNameToMidi(note) {
            const noteMap = { C: 0, "C#": 1, D: 2, "D#": 3, E: 4, F: 5, "F#": 6, G: 7, "G#": 8, A: 9, "A#": 10, B: 11 };
            const match = note.match(/([A-G]#?)(-?\d+)/);
            if (!match) return null;
            const [, name, octave] = match;
            return noteMap[name] + (parseInt(octave) + 1) * 12;
        }

        // --- SYNTH PARAMETER DEFAULTS ---
        const getDefaultSynthParams = (type = 'VA') => {
            switch(type) {
                case 'FM':
                    return {
                        harmonicity: 3, modulationIndex: 10, detune: 0,
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.8 },
                        modulation: { type: "square" },
                        modulationEnvelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 }
                    };
                case 'Pluck':
                    return { attackNoise: 1, dampening: 4000, resonance: 0.9 };
                case 'Wavefolder':
                case 'VA':
                default:
                    return {
                        oscillator: { type: 'fatsawtooth', count: 3, detune: 15 },
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 0.8 },
                        filter: { Q: 2, type: 'lowpass', rolloff: -12, frequency: 20000 },
                        filterEnvelope: { attack: 0.06, decay: 0.2, sustain: 0.5, release: 2, baseFrequency: 200, octaves: 7 }
                    };
            }
        };

        // --- AUDIO & TRACK INITIALIZATION ---
        function createSynth(type = 'VA', params) {
            let synth;
            const synthParams = params || getDefaultSynthParams(type);
            switch(type) {
                case 'FM': synth = new Tone.PolySynth(Tone.FMSynth, synthParams); break;
                case 'Pluck': synth = new Tone.PolySynth(Tone.PluckSynth, synthParams); break;
                case 'Wavefolder':
                    const shaper = new Tone.WaveShaper(val => Math.tanh(val * 4));
                    const fatOsc = new Tone.PolySynth(Tone.Synth, synthParams).connect(shaper);
                    synth = { _source: fatOsc, _shaper: shaper, connect: function(dest) { this._shaper.connect(dest); return this; }, triggerAttackRelease: function(...args) { return this._source.triggerAttackRelease(...args); }, triggerAttack: function(...args) { return this._source.triggerAttack(...args); }, triggerRelease: function(...args) { return this._source.triggerRelease(...args); }, get: function(...args) { return this._source.get(...args); }, set: function(...args) { return this._source.set(...args); }, dispose: function() { this._source.dispose(); this._shaper.dispose(); } };
                    break;
                case 'VA': 
                default: 
                    synth = new Tone.PolySynth(Tone.Synth, synthParams);
            }
            return synth;
        }

        function createNewTrack(index) {
            const channel = new Tone.Channel({ volume: 0, pan: 0 }).toDestination();
            const reverb = new Tone.Reverb({ wet: 0, decay: 1.5 }).connect(channel);
            const delay = new Tone.FeedbackDelay({ wet: 0, delayTime: "8n", feedback: 0.5 }).connect(reverb);
            const phaser = new Tone.Phaser({ wet: 0, frequency: 0.5, octaves: 3, baseFrequency: 350 }).connect(delay);
            
            const initialParams = getDefaultSynthParams('VA');
            const source = createSynth('VA', initialParams).connect(phaser);
            
            return { name: `Track ${index + 1}`, source, type: 'Synth', algorithm: 'VA', channel, reverb, delay, phaser, midiInPortId: "none", midiOutPortId: "none", midiInChan: "all", midiOutChan: 1, muteInternal: false, isMuted: false, pitch: 0, synthParams: initialParams };
        }
        
        // --- UI RENDERING ---
        function renderAll() {
            renderModals();
            renderGrid();
            renderNoteInputGrid();
        }
        
        function renderModals() {
            dom.modalsContainer.innerHTML = `
                <!-- MIDI Permission Modal -->
                <div id="midi-permission-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden p-4 z-50">
                    <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border border-gray-700 space-y-4">
                        <h2 class="text-2xl font-bold text-yellow-400">MIDI Permission Required</h2>
                        <p class="text-gray-300">To use MIDI devices, please grant this site permission to access them. This is a browser security feature.</p>
                        <p class="text-gray-400 text-sm">Look for a permission prompt in your browser's address bar. You may need to reload the page after granting permission.</p>
                        <div class="text-right"><button class="close-modal-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">OK</button></div>
                    </div>
                </div>
                <!-- Track Settings Modal -->
                <div id="track-settings-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden p-4 z-50">
                    <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg border border-gray-700 space-y-4 max-h-[90vh] modal-scroll-content overflow-y-auto">
                        <h2 id="track-modal-title" class="text-2xl font-bold text-white"></h2>
                        <div class="space-y-2 p-3 bg-gray-700/50 rounded-lg"><h3 class="font-semibold">Mixer</h3>
                            <div class="flex items-center"><label class="w-20">Volume</label><input type="range" id="track-volume" min="-40" max="6" step="0.1" class="w-full"></div>
                            <div class="flex items-center"><label class="w-20">Pan</label><input type="range" id="track-pan" min="-1" max="1" step="0.01" class="w-full"></div>
                            <div class="flex items-center"><label class="w-28">Mute Internal</label><button id="mute-internal-btn" class="toggle-btn"></button></div>
                        </div>
                        <div class="space-y-2 p-3 bg-gray-700/50 rounded-lg"><h3 class="font-semibold">Effects</h3>
                             <div class="flex items-center"><label class="w-16">Reverb</label><input type="range" id="track-reverb" min="0" max="1" step="0.01" class="w-full"></div>
                            <div class="flex items-center"><label class="w-16">Delay</label><input type="range" id="track-delay" min="0" max="1" step="0.01" class="w-full"></div>
                            <div class="flex items-center"><label class="w-16">Phaser</label><input type="range" id="track-phaser" min="0" max="1" step="0.01" class="w-full"></div>
                        </div>
                        <div id="instrument-params-container" class="space-y-2 p-3 bg-gray-700/50 rounded-lg">
                            <h3 id="instrument-params-title" class="font-semibold"></h3>
                            <div id="instrument-params-content"></div>
                        </div>
                        <div class="text-right"><button class="close-modal-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Close</button></div>
                    </div>
                </div>
                <!-- MIDI Settings Modal -->
                <div id="midi-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden p-4 z-50">
                    <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border border-gray-700 flex flex-col max-h-[90vh]">
                        <h2 class="text-2xl font-bold text-white mb-4">MIDI I/O Settings</h2>
                        <div id="midi-track-settings" class="space-y-4 overflow-y-auto pr-2"></div>
                        <div class="text-right mt-4 flex-shrink-0"><button class="close-modal-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Close</button></div>
                    </div>
                </div>
                <!-- Step Detail Modal -->
                <div id="step-detail-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden p-4 z-50">
                    <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border border-gray-700 space-y-4">
                        <h2 id="step-modal-title" class="text-2xl font-bold text-white"></h2>
                        <div class="space-y-2 p-3 bg-gray-700/50 rounded-lg">
                            <div class="flex items-center"><label class="w-24">Velocity</label><input type="range" id="step-velocity" min="1" max="127" step="1" class="w-full"><span id="step-velocity-display" class="ml-2 w-8 text-center"></span></div>
                            <div class="flex items-center"><label class="w-24">Offset (%)</label><input type="range" id="step-offset" min="-50" max="50" step="1" class="w-full"><span id="step-offset-display" class="ml-2 w-8 text-center"></span></div>
                            <div class="flex items-center"><label class="w-24">Ratchet</label><select id="step-ratchet" class="w-full bg-gray-600 rounded p-1"><option value="1">1x</option><option value="2">2x</option><option value="3">3x</option><option value="4">4x</option></select></div>
                        </div>
                        <div class="text-right"><button class="close-modal-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Close</button></div>
                    </div>
                </div>
            `;
        }

        function renderGrid() {
            dom.gridContainer.innerHTML = '';
            state.tracks.forEach((track, trackIndex) => {
                const trackDiv = document.createElement('div');
                trackDiv.className = `track-row p-2 grid grid-cols-[auto_1fr] gap-x-4 items-center ${trackIndex === state.selectedTrackIndex ? 'selected' : ''}`;
                trackDiv.id = `track-row-${trackIndex}`;
                trackDiv.dataset.trackIndex = trackIndex;

                const mainContentDiv = document.createElement('div');
                mainContentDiv.className = "flex flex-col gap-2";
                
                const isSelectedAndArmed = state.armedTrackIndex === trackIndex && !state.isPlaying;
                
                if (isSelectedAndArmed) {
                    const playheadDiv = document.createElement('div');
                    playheadDiv.className = 'flex justify-center items-center gap-4';
                    playheadDiv.innerHTML = `
                         <button class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded-lg text-lg" data-action="playhead-left">&larr;</button>
                         <span class="text-xs text-gray-400">STEP RECORD</span>
                         <button class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded-lg text-lg" data-action="playhead-right">&rarr;</button>
                    `;
                    mainContentDiv.appendChild(playheadDiv);
                }
                
                const stepsWrapper = document.createElement('div');
                stepsWrapper.className = 'grid grid-cols-8 grid-rows-2 gap-1.5';
                
                for (let stepIndex = 0; stepIndex < NUM_STEPS; stepIndex++) { 
                    const hasNotes = state.stepGrid[trackIndex]?.[stepIndex]?.length > 0;
                    const stepButton = document.createElement('button');
                    stepButton.className = `step h-10 w-full rounded-md ${(stepIndex % 4 === 0) ? 'accent' : ''} ${hasNotes ? 'active' : ''}`;
                    stepButton.dataset.step = stepIndex;
                    stepButton.dataset.action = "handle-step-click";
                    stepButton.dataset.dblaction = "open-step-detail";
                    stepsWrapper.appendChild(stepButton);
                }
                mainContentDiv.appendChild(stepsWrapper);

                const infoPanelWrapper = document.createElement('div');
                infoPanelWrapper.innerHTML = `
                    <div class="flex flex-col sm:flex-row items-center gap-2 flex-shrink-0 cursor-pointer" data-action="select-track">
                        <div class="w-24 font-semibold text-gray-400 truncate text-right" data-action="edit-track-name">${track.name}</div>
                        <div class="flex flex-col gap-1 w-28">
                            <div class="flex items-center gap-1">
                                <button class="arm-btn text-xs bg-gray-600 hover:bg-gray-500 px-2 py-1 rounded grow ${trackIndex === state.armedTrackIndex ? 'armed' : ''}" data-action="arm-track">Arm</button>
                                <button class="mute-btn text-xs px-2 py-1 rounded w-8 ${track.isMuted ? 'muted' : 'bg-gray-600 hover:bg-gray-500'}" title="Mute Track" data-action="toggle-mute">M</button>
                                <button class="solo-btn text-xs px-2 py-1 rounded w-8 ${trackIndex === state.soloedTrackIndex ? 'soloed' : 'bg-gray-600 hover:bg-gray-500'}" title="Solo Track" data-action="toggle-solo">S</button>
                            </div>
                            <button class="text-xs bg-gray-600 hover:bg-gray-500 px-2 py-1 rounded w-full" data-action="open-track-settings">Settings</button>
                            <button class="text-xs bg-gray-600 hover:bg-gray-500 px-2 py-1 rounded w-full" data-action="load-sample">Load Sample</button>
                            <input type="file" accept=".wav,.aif,.aiff,.mp3" class="hidden" data-action="load-sample-input">
                            <button class="clear-btn text-xs bg-red-800 hover:bg-red-700 px-2 py-1 rounded w-full ${track.type !== 'Sampler' ? 'hidden' : ''}" data-action="clear-sample">Clear</button>
                        </div>
                    </div>
                `;
                
                trackDiv.appendChild(infoPanelWrapper.firstElementChild);
                trackDiv.appendChild(mainContentDiv);
                dom.gridContainer.appendChild(trackDiv);
            });
        }
        
        function renderNoteInputGrid() {
            dom.noteInputGrid.innerHTML = '';
            for (let oct = 0; oct < NOTE_INPUT_OCTAVES; oct++) {
                for(let i = 0; i < 12; i++) {
                    const noteIndex = i % 12;
                    const octave = NOTE_INPUT_START_OCTAVE + oct;
                    const noteName = `${NOTE_NAMES[noteIndex]}${octave}`;
                    const isSharp = noteName.includes('#');
                    const btn = document.createElement('button');
                    btn.className = `note-input-btn rounded-md text-xs font-mono h-full ${isSharp ? 'sharp col-start-auto' : 'col-span-1'}`;
                    btn.dataset.note = noteName;
                    dom.noteInputGrid.appendChild(btn);
                }
            }
        }
        
        // --- UI UPDATES (Optimized) ---
        function updatePlayheadUI(prevStep, nextStep) {
            if (prevStep > -1) document.querySelectorAll(`[data-step="${prevStep}"]`).forEach(el => el.classList.remove('current'));
            if (nextStep > -1) document.querySelectorAll(`[data-step="${nextStep}"]`).forEach(el => el.classList.add('current'));
        }

        function updateStepButtonUI(trackIndex, stepIndex) {
            const stepButton = document.querySelector(`[data-track-index="${trackIndex}"] [data-step="${stepIndex}"]`);
            if (stepButton) {
                stepButton.classList.toggle('active', state.stepGrid[trackIndex]?.[stepIndex]?.length > 0);
            }
        }

        function updateTrackSelectionUI(prevIndex, nextIndex) {
            if (prevIndex > -1) document.getElementById(`track-row-${prevIndex}`)?.classList.remove('selected');
            if (nextIndex > -1) document.getElementById(`track-row-${nextIndex}`)?.classList.add('selected');
        }

        function updateArmButtonUI(trackIndex) {
             const armBtn = document.querySelector(`#track-row-${trackIndex} [data-action="arm-track"]`);
             if (armBtn) armBtn.classList.toggle('armed', state.armedTrackIndex === trackIndex);
        }

        function updateMuteSoloUI() {
            state.tracks.forEach((track, index) => {
                const row = document.getElementById(`track-row-${index}`);
                if (!row) return;
                const isSoloed = state.soloedTrackIndex > -1;
                const isMuted = track.isMuted;
                const effectiveMute = isSoloed ? (index !== state.soloedTrackIndex) : isMuted;

                track.channel.mute = effectiveMute;
                
                const muteBtn = row.querySelector('[data-action="toggle-mute"]');
                const soloBtn = row.querySelector('[data-action="toggle-solo"]');
                if (muteBtn) muteBtn.classList.toggle('muted', isMuted);
                if (soloBtn) soloBtn.classList.toggle('soloed', index === state.soloedTrackIndex);
            });
        }
        
        // --- LOGIC & ACTIONS ---
        function addTrack() { 
            const newIndex = state.tracks.length;
            state.tracks.push(createNewTrack(newIndex)); 
            state.stepGrid.push(Array.from({ length: 32 }, () => []));
            state.nonPlayStepIndices.push(0);
            renderGrid(); 
        }
        function removeLastTrack() {
            if (state.tracks.length <= 1) return;
            const wasArmed = state.armedTrackIndex === state.tracks.length - 1;
            const wasSelected = state.selectedTrackIndex === state.tracks.length - 1;

            const removedTrack = state.tracks.pop();
            if(removedTrack.source) removedTrack.source.dispose(); 
            if(removedTrack.channel) removedTrack.channel.dispose();
            state.stepGrid.pop();
            state.nonPlayStepIndices.pop();

            if (wasArmed) state.armedTrackIndex = -1;
            if (wasSelected) selectTrack(state.selectedTrackIndex - 1);
            if (state.soloedTrackIndex === state.tracks.length) {
                state.soloedTrackIndex = -1;
                updateMuteSoloUI();
            }
            renderGrid();
        }

        function selectTrack(trackIndex) {
            if (trackIndex < 0 || trackIndex >= state.tracks.length || trackIndex === state.selectedTrackIndex) return;
            const prevIndex = state.selectedTrackIndex;
            state.selectedTrackIndex = trackIndex;
            updateTrackSelectionUI(prevIndex, trackIndex);
        }

        function armTrack(trackIndex) {
            const prevArmed = state.armedTrackIndex;
            if (prevArmed === trackIndex) {
                state.armedTrackIndex = -1;
            } else {
                state.armedTrackIndex = trackIndex;
                if(state.selectedTrackIndex !== trackIndex) selectTrack(trackIndex);
            }
            renderGrid(); 
            updateNextRecordStepVisual();
        }

        function toggleMute(trackIndex) {
            state.tracks[trackIndex].isMuted = !state.tracks[trackIndex].isMuted;
            updateMuteSoloUI();
        }

        function toggleSolo(trackIndex) {
            state.soloedTrackIndex = (state.soloedTrackIndex === trackIndex) ? -1 : trackIndex;
            updateMuteSoloUI();
        }

        function updateNextRecordStepVisual() {
            document.querySelectorAll('.next-record-step').forEach(el => el.classList.remove('next-record-step'));
            if (!state.isPlaying && state.armedTrackIndex > -1) {
                const nextStepIndex = state.nonPlayStepIndices[state.armedTrackIndex];
                const nextStepElement = document.querySelector(`[data-track-index="${state.armedTrackIndex}"] [data-step="${nextStepIndex}"]`);
                if (nextStepElement) nextStepElement.classList.add('next-record-step');
            }
        }
        
        function handleStepClick(trackIndex, stepIndex, event) {
            if (event.ctrlKey || event.metaKey) {
                clearStep(trackIndex, stepIndex);
                return;
            }
            
            const track = state.tracks[trackIndex];
            if (track.type === 'Sampler') {
                const stepHasNote = state.stepGrid[trackIndex][stepIndex].length > 0;
                if (stepHasNote) {
                    clearStep(trackIndex, stepIndex);
                } else {
                    recordNote(trackIndex, stepIndex, 'C4', 100, 0, 1);
                    if (!track.channel.mute) {
                        const pitchOffset = track.pitch || 0;
                        const finalNote = midiToNoteName(noteNameToMidi('C4') + pitchOffset);
                        track.source.triggerAttack(finalNote);
                    }
                }
            } else if (track.type === 'Synth') {
                 if (state.stepGrid[trackIndex][stepIndex].length === 0 && state.armedTrackIndex === trackIndex) {
                    state.nonPlayStepIndices[state.armedTrackIndex] = stepIndex;
                    updateNextRecordStepVisual();
                 } else {
                    clearStep(trackIndex, stepIndex);
                 }
            }
        }
        
        function handleNoteOn(note, velocity = 100) {
            const activeTrackForPlayback = (state.armedTrackIndex > -1) ? state.armedTrackIndex : state.selectedTrackIndex;
            state.liveNotes.add(note);

            if (activeTrackForPlayback > -1) {
                const track = state.tracks[activeTrackForPlayback];
                if (!track.muteInternal && !track.channel.mute) {
                    if (track.type === 'Sampler') {
                         const pitchOffset = track.pitch || 0;
                        const finalNote = midiToNoteName(noteNameToMidi('C4') + pitchOffset);
                        track.source.triggerAttack(finalNote, Tone.now(), velocity/127);
                    } else {
                        track.source.triggerAttack(note, Tone.now(), velocity / 127);
                    }
                }

                if (state.armedTrackIndex > -1) {
                    if (state.isPlaying && state.currentStep > -1) {
                        recordNote(state.armedTrackIndex, state.currentStep, note, velocity, 0, 1);
                    } else if (!state.isPlaying) {
                        const recordStep = state.nonPlayStepIndices[state.armedTrackIndex];
                        recordNote(state.armedTrackIndex, recordStep, note, velocity, 0, 1);
                        if(state.liveNotes.size === 1) { // Advance only on the first note of a chord
                            state.nonPlayStepIndices[state.armedTrackIndex] = (recordStep + 1) % NUM_STEPS;
                            updateNextRecordStepVisual();
                        }
                    }
                }
            }
            document.querySelector(`[data-note="${note}"]`)?.classList.add('pressed');
        }

        function handleNoteOff(note) {
            if (!note) return;
            state.liveNotes.delete(note);
            const activeTrackForPlayback = (state.armedTrackIndex > -1) ? state.armedTrackIndex : state.selectedTrackIndex;
            if (activeTrackForPlayback > -1) {
                const track = state.tracks[activeTrackForPlayback];
                if (track.type === 'Synth' && typeof track.source.triggerRelease === 'function' && !track.muteInternal) {
                    track.source.triggerRelease(note);
                }
            }
            document.querySelector(`[data-note="${note}"]`)?.classList.remove('pressed');
            if (state.lastPressedNote === note) {
                state.lastPressedNote = null;
            }
        }

        function recordNote(trackIndex, stepIndex, note, velocity, offset, ratchet) {
            const stepData = state.stepGrid[trackIndex][stepIndex];
            if (!stepData.some(n => n.note === note)) {
                stepData.push({ note, velocity, offset, ratchet });
                stepData.sort((a,b) => (noteNameToMidi(a.note) || 0) - (noteNameToMidi(b.note) || 0));
                updateStepButtonUI(trackIndex, stepIndex);
            }
        }

        function clearStep(trackIndex, stepIndex) {
            state.stepGrid[trackIndex][stepIndex] = [];
            updateStepButtonUI(trackIndex, stepIndex);
        }
        
        function loadSample(event, trackIndex) {
            const file = event.target.files[0]; if (!file) return;
            const url = URL.createObjectURL(file);
            const sampler = new Tone.Sampler({ 
                urls: { C4: url },
                attack: 0.01,
                release: 0.1,
                onload: () => {
                    if (state.tracks[trackIndex].source) state.tracks[trackIndex].source.dispose();
                    state.tracks[trackIndex].source = sampler.connect(state.tracks[trackIndex].phaser);
                    state.tracks[trackIndex].name = file.name.replace(/\.[^/.]+$/, "");
                    state.tracks[trackIndex].type = 'Sampler';
                    state.tracks[trackIndex].pitch = 0; // Add pitch property for samplers
                    renderGrid(); // Re-render the grid to show new track name and clear button
                    URL.revokeObjectURL(url);
                }
            });
        }
        function clearSample(trackIndex) {
            const track = state.tracks[trackIndex];
            if (track.type !== 'Sampler') return;
            if (track.source) track.source.dispose();
            
            const newParams = getDefaultSynthParams('VA');
            track.source = createSynth('VA', newParams).connect(track.phaser);
            track.name = `Track ${trackIndex + 1}`;
            track.type = 'Synth';
            track.synthParams = newParams;
            delete track.pitch;
            renderGrid();
        }

        // --- SEQUENCER & AUDIO LOGIC ---
        const sequenceLoop = new Tone.Sequence((time, step) => {
            Tone.Draw.schedule(() => {
                updatePlayheadUI(state.currentStep, step);
                state.currentStep = step;
            }, time);
            
            state.tracks.forEach((track, trackIndex) => {
                const notesInStep = state.stepGrid[trackIndex]?.[step];
                if (notesInStep && notesInStep.length > 0) {
                    const sixteenthDur = Tone.Time('16n').toSeconds();
                    const firstNoteData = notesInStep[0]; 
                    const velocity = firstNoteData.velocity || 100;
                    const offset = firstNoteData.offset || 0;
                    const mainOffsetSec = sixteenthDur * (offset / 100);
                    const ratchetCount = firstNoteData.ratchet || 1;
                    const ratchetDurSec = sixteenthDur / ratchetCount;

                    if (!track.muteInternal) {
                        if (track.type === 'Sampler') track.source.releaseAll(time);
                        for (let i = 0; i < ratchetCount; i++) {
                            const ratchetOffset = i * ratchetDurSec;
                            const triggerTime = time + mainOffsetSec + ratchetOffset;
                            const noteNames = notesInStep.map(n => n.note);
                            const velNorm = velocity / 127;
                            if (track.type === 'Sampler') {
                                const pitchOffset = track.pitch || 0;
                                const baseMidi = noteNameToMidi('C4');
                                if (baseMidi !== null) {
                                    const finalNote = midiToNoteName(baseMidi + pitchOffset);
                                    track.source.triggerAttack(finalNote, triggerTime, velNorm);
                                }
                            } else {
                                const duration = Tone.Time(ratchetDurSec * 0.9);
                                track.source.triggerAttackRelease(noteNames, duration, triggerTime, velNorm);
                            }
                        }
                    }

                    if (track.midiOutPortId !== 'none' && state.midi.access) {
                        const output = state.midi.outputs.find(o => o.id === track.midiOutPortId);
                        if (output) {
                            notesInStep.forEach(noteData => {
                                const midiNote = noteNameToMidi(noteData.note);
                                if (midiNote === null) return;
                                const onTime = performance.now() + ((time + mainOffsetSec) - Tone.now()) * 1000;
                                const offTime = onTime + (sixteenthDur * 0.9 * 1000);
                                output.send([0x90 + (parseInt(track.midiOutChan) - 1), midiNote, velocity], onTime);
                                output.send([0x80 + (parseInt(track.midiOutChan) - 1), midiNote, 0], offTime);
                            });
                        }
                    }
                }
            });
        }, Array.from({ length: NUM_STEPS }, (_, i) => i), '16n').start(0);

        async function togglePlayback(forceState) {
            if (Tone.context.state !== 'running') await Tone.start();
            const targetState = typeof forceState === 'boolean' ? forceState : !state.isPlaying;
            if (targetState) {
                Tone.Transport.start();
                state.isPlaying = true;
                dom.playStopBtn.textContent = 'Stop';
                dom.playStopBtn.classList.add('bg-red-600'); dom.playStopBtn.classList.remove('bg-blue-600');
                renderGrid();
                updateNextRecordStepVisual();
            } else { 
                Tone.Transport.stop();
                state.tracks.forEach(track => { if (track.source && typeof track.source.releaseAll === 'function') track.source.releaseAll(); });
                state.isPlaying = false;
                dom.playStopBtn.textContent = 'Play';
                dom.playStopBtn.classList.add('bg-blue-600'); dom.playStopBtn.classList.remove('bg-red-600');
                renderGrid();
                updatePlayheadUI(state.currentStep, -1);
                state.currentStep = -1;
                updateNextRecordStepVisual();
            }
        }
        
        // --- MIDI HANDLING ---
        function initializeMidi() {
            if (navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess({ sysex: true })
                .then(onMidiSuccess)
                .catch(e => {
                    console.error("MIDI Error:", e);
                    const modal = document.getElementById('midi-permission-modal');
                    if (modal) modal.classList.remove('hidden');
                });
            } else {
                console.warn("Web MIDI API is not supported in this browser.");
            }
        }

        function onMidiSuccess(access) {
            state.midi.access = access;
            updateMidiDeviceLists();
            state.midi.access.onstatechange = () => updateMidiDeviceLists();
        }
        
        function updateMidiDeviceLists() {
            if (!state.midi.access) return;

            state.midi.inputs = Array.from(state.midi.access.inputs.values());
            state.midi.outputs = Array.from(state.midi.access.outputs.values());
            
            const oldClockVal = dom.clockSourceSelect.value;
            while (dom.clockSourceSelect.options.length > 1) { dom.clockSourceSelect.remove(1); }
            state.midi.inputs.forEach(input => {
                const option = document.createElement('option');
                option.value = input.id; option.textContent = input.name;
                dom.clockSourceSelect.appendChild(option);
            });

            if (state.midi.inputs.some(i => i.id === oldClockVal)) {
                dom.clockSourceSelect.value = oldClockVal;
            } else {
                dom.clockSourceSelect.value = 'internal';
                handleClockSourceChange();
            }
            
            const midiModal = document.getElementById('midi-modal');
            if (midiModal && !midiModal.classList.contains('hidden')) {
                renderMidiSettings();
            }

            state.midi.access.inputs.forEach(input => input.onmidimessage = onMidiMessage);
        }
        
        function handleClockSourceChange() {
            state.midi.clockSourceId = dom.clockSourceSelect.value;
            if (state.midi.clockSourceId === 'internal') {
                dom.tempoSlider.disabled = false;
                Tone.Transport.bpm.value = dom.tempoSlider.value;
            } else {
                dom.tempoSlider.disabled = true;
                state.midi.lastClockTime = 0;
                state.midi.clockIntervals.length = 0;
            }
        }
        
        function onMidiMessage(event) {
            const command = event.data[0];
            const type = command & 0xF0;

            // --- MIDI Clock Handling ---
            if (event.target.id === state.midi.clockSourceId && state.midi.clockSourceId !== 'internal') {
                switch(command) {
                    case 250: // START
                        state.midi.lastClockTime = 0;
                        state.midi.clockIntervals.length = 0;
                        togglePlayback(true); 
                        return;
                    case 252: // STOP
                        togglePlayback(false); 
                        state.midi.lastClockTime = 0;
                        state.midi.clockIntervals.length = 0;
                        dom.tempoDisplay.textContent = dom.tempoSlider.value;
                        return;
                    case 248: // CLOCK
                        const now = performance.now();
                        if (state.midi.lastClockTime > 0) {
                            const interval = now - state.midi.lastClockTime;
                            state.midi.clockIntervals.push(interval);
                            if (state.midi.clockIntervals.length > CLOCK_INTERVAL_BUFFER_SIZE) { state.midi.clockIntervals.shift(); }
                            const avgInterval = state.midi.clockIntervals.reduce((a, b) => a + b, 0) / state.midi.clockIntervals.length;
                            const bpm = 60000 / (avgInterval * 24);
                            if (isFinite(bpm) && bpm > 20 && bpm < 350) {
                                 Tone.Transport.bpm.value = bpm;
                                 dom.tempoDisplay.textContent = Math.round(bpm);
                            }
                        }
                        state.midi.lastClockTime = now;
                        return;
                }
            }
            
            // --- MIDI Note & CC Handling ---
            if (type !== 0x90 && type !== 0x80) return; // Ignore non-note messages
            
            const ch = (command & 0x0F) + 1;
            const [_, noteNumber, velocity] = event.data;

            state.tracks.forEach((track, trackIndex) => {
                const isListening = (track.midiInPortId === 'none' || track.midiInPortId === event.target.id) && (track.midiInChan === 'all' || parseInt(track.midiInChan) === ch);
                const isFeedbackLoop = track.midiOutPortId !== 'none' && track.midiOutPortId === event.target.id;
                
                if (isListening && !isFeedbackLoop) {
                    const isArmedOrSelected = (state.armedTrackIndex === trackIndex) || (state.armedTrackIndex === -1 && state.selectedTrackIndex === trackIndex);
                    if (isArmedOrSelected) {
                         if (type === 0x90 && velocity > 0) handleNoteOn(midiToNoteName(noteNumber), velocity);
                         else if (type === 0x80 || (type === 0x90 && velocity === 0)) handleNoteOff(midiToNoteName(noteNumber));
                    }
                }
            });
        }
        
        // --- MODAL & CONTROLS ---
        function openTrackSettingsModal(trackIndex) {
            state.activeModalTrackIndex = trackIndex;
            const track = state.tracks[trackIndex];
            const modal = document.getElementById('track-settings-modal');
            modal.querySelector('#track-modal-title').textContent = `${track.name} Settings`;
            modal.querySelector('#track-volume').value = track.channel.volume.value;
            modal.querySelector('#track-pan').value = track.channel.pan.value;
            modal.querySelector('#track-reverb').value = track.reverb.wet.value;
            modal.querySelector('#track-delay').value = track.delay.wet.value;
            modal.querySelector('#track-phaser').value = track.phaser.wet.value;

            const muteBtn = modal.querySelector('#mute-internal-btn');
            muteBtn.textContent = track.muteInternal ? 'On' : 'Off';
            muteBtn.classList.toggle('active', track.muteInternal);

            const paramsTitle = modal.querySelector('#instrument-params-title');
            const paramsContent = modal.querySelector('#instrument-params-content');
            paramsContent.innerHTML = ''; // Clear previous content

            if (track.type === 'Sampler') {
                paramsTitle.textContent = 'Sampler Parameters';
                const source = track.source;
                const pitch = track.pitch || 0;
                paramsContent.innerHTML = `
                    <div class="flex items-center"><label class="w-28 text-sm">Pitch (Semi)</label><input type="range" id="sampler-pitch" value="${pitch}" min="-24" max="24" step="1" class="w-full instrument-control"><span id="sampler-pitch-display" class="ml-2 w-10 text-center text-xs">${pitch}</span></div>
                    <div class="flex items-center"><label class="w-28 text-sm">Attack</label><input type="range" id="sampler-attack" value="${source.attack}" min="0" max="1" step="0.01" class="w-full instrument-control"></div>
                    <div class="flex items-center"><label class="w-28 text-sm">Release</label><input type="range" id="sampler-release" value="${source.release}" min="0.01" max="4" step="0.01" class="w-full instrument-control"></div>
                    <div class="flex items-center"><label class="w-28 text-sm">Reverse</label><button id="sampler-reverse-btn" class="toggle-btn ${source.reverse ? 'active' : ''}">${source.reverse ? 'On' : 'Off'}</button></div>
                `;
            } else { // 'Synth'
                paramsTitle.textContent = 'Synth Parameters';
                const algoOptions = Object.entries(SYNTH_ALGORITHMS).map(([key, name]) => `<option value="${key}" ${key === track.algorithm ? 'selected' : ''}>${name}</option>`).join('');
                paramsContent.innerHTML = `<div class="flex items-center"><label class="w-24 text-sm">Algorithm</label><select id="synth-algorithm" class="w-full bg-gray-600 rounded p-1 instrument-control">${algoOptions}</select></div><div id="dynamic-synth-params"></div>`;
                renderDynamicSynthParams(track);
            }
            modal.classList.remove('hidden');
        }

        function handleAlgorithmChange(newAlgo) {
            if (state.activeModalTrackIndex < 0) return;
            const track = state.tracks[state.activeModalTrackIndex];
            if (track.source) track.source.dispose();
            
            const newParams = getDefaultSynthParams(newAlgo);
            track.synthParams = newParams;
            track.source = createSynth(newAlgo, newParams).connect(track.phaser);
            track.algorithm = newAlgo;

            openTrackSettingsModal(state.activeModalTrackIndex);
        }

        function renderDynamicSynthParams(track) {
            const container = document.getElementById('dynamic-synth-params');
            if (!container || !track.synthParams) return;
            
            const params = track.synthParams;
            const oscParams = params.oscillator;
            const envParams = params.envelope;
            const filterParams = params.filter;
            const filterEnvParams = params.filterEnvelope;

            const createSlider = (label, obj, objName, prop, min, max, step) => {
                const val = obj[prop] ?? 0;
                const dataAttrs = `data-param-object="${objName}" data-param="${prop}"`;
                return `<div class="flex items-center"><label class="w-28 text-sm">${label}</label><input type="range" ${dataAttrs} value="${val}" min="${min}" max="${max}" step="${step}" class="w-full instrument-control"></div>`;
            }
            
            let html = `
                <hr class="border-gray-600 my-2"><h4 class="text-sm font-semibold text-gray-400">Oscillator</h4>
                <div class="flex items-center"><label class="w-28 text-sm">Type</label><select data-param-object="oscillator" data-param="type" class="w-full bg-gray-600 rounded p-1 instrument-control">${['sine', 'square', 'sawtooth', 'triangle', 'fatsawtooth', 'pulse', 'pwm'].map(o => `<option value="${o}" ${o === oscParams.type ? 'selected' : ''}>${o}</option>`).join('')}</select></div>
                ${createSlider('Detune', oscParams, 'oscillator', 'detune', 0, 100, 0.1)}
                <hr class="border-gray-600 my-2"><h4 class="text-sm font-semibold text-gray-400">Amp Env</h4>
                ${createSlider('Attack', envParams, 'envelope', 'attack', 0.001, 1, 0.001)}
                ${createSlider('Decay', envParams, 'envelope', 'decay', 0.01, 2, 0.01)}
                ${createSlider('Sustain', envParams, 'envelope', 'sustain', 0, 1, 0.01)}
                ${createSlider('Release', envParams, 'envelope', 'release', 0.01, 4, 0.01)}
            `;

            if (filterParams && filterEnvParams) {
                html += `
                    <hr class="border-gray-600 my-2"><h4 class="text-sm font-semibold text-gray-400">Filter</h4>
                    <div class="flex items-center"><label class="w-28 text-sm">Type</label><select data-param-object="filter" data-param="type" class="w-full bg-gray-600 rounded p-1 instrument-control">${['lowpass', 'highpass', 'bandpass'].map(o => `<option value="${o}" ${o === filterParams.type ? 'selected' : ''}>${o}</option>`).join('')}</select></div>
                    ${createSlider('Cutoff', filterParams, 'filter', 'frequency', 20, 20000, 1)}
                    ${createSlider('Resonance', filterParams, 'filter', 'Q', 0.1, 10, 0.1)}
                    <hr class="border-gray-600 my-2"><h4 class="text-sm font-semibold text-gray-400">Filter Env</h4>
                    ${createSlider('Attack', filterEnvParams, 'filterEnvelope', 'attack', 0.001, 2, 0.001)}
                    ${createSlider('Decay', filterEnvParams, 'filterEnvelope', 'decay', 0.01, 2, 0.01)}
                    ${createSlider('Sustain', filterEnvParams, 'filterEnvelope', 'sustain', 0, 1, 0.01)}
                    ${createSlider('Release', filterEnvParams, 'filterEnvelope', 'release', 0.01, 4, 0.01)}
                    ${createSlider('Amount', filterEnvParams, 'filterEnvelope', 'octaves', 0, 8, 0.1)}
                    ${createSlider('Base Freq', filterEnvParams, 'filterEnvelope', 'baseFrequency', 20, 5000, 1)}
                `;
            }
            container.innerHTML = html;
        }

        function handleTrackSettingsChange(e) {
            if (state.activeModalTrackIndex < 0) return;
            const track = state.tracks[state.activeModalTrackIndex];
            const el = e.target;
            const val = el.type === 'range' || el.type === 'select-one' ? el.value : null;

            switch (el.id) {
                case 'track-volume': track.channel.volume.value = parseFloat(val); return;
                case 'track-pan': track.channel.pan.value = parseFloat(val); return;
                case 'track-reverb': track.reverb.wet.value = parseFloat(val); return;
                case 'track-delay': track.delay.wet.value = parseFloat(val); return;
                case 'track-phaser': track.phaser.wet.value = parseFloat(val); return;
                case 'mute-internal-btn': track.muteInternal = !track.muteInternal; el.textContent = track.muteInternal ? 'On' : 'Off'; el.classList.toggle('active', track.muteInternal); return;
                case 'sampler-pitch': track.pitch = parseInt(val); document.getElementById('sampler-pitch-display').textContent = val; return;
                case 'sampler-attack': track.source.attack = parseFloat(val); return;
                case 'sampler-release': track.source.release = parseFloat(val); return;
                case 'sampler-reverse-btn':
                    track.source.reverse = !track.source.reverse;
                    el.textContent = track.source.reverse ? 'On' : 'Off';
                    el.classList.toggle('active', track.source.reverse);
                    return;
                case 'synth-algorithm': handleAlgorithmChange(val); return;
            }

            if (el.classList.contains('instrument-control')) {
                const { param, paramObject } = el.dataset;
                const paramValue = el.type === 'range' ? parseFloat(el.value) : el.value;

                if(param && paramObject && track.synthParams[paramObject]) {
                    track.synthParams[paramObject][param] = paramValue;
                    track.source.set({ [paramObject]: { [param]: paramValue } });
                    
                    if (param === 'type' && paramObject === 'oscillator') {
                        renderDynamicSynthParams(track); 
                    }
                }
            }
        }

        function openStepDetailModal(trackIndex, stepIndex) {
            const stepData = state.stepGrid[trackIndex] ?.[stepIndex];
            if (!stepData || stepData.length === 0) return;
            state.activeModalStep = { track: trackIndex, step: stepIndex };
            const firstNote = stepData[0];
            const modal = document.getElementById('step-detail-modal');
            modal.querySelector('#step-modal-title').textContent = `Track ${trackIndex+1}, Step ${stepIndex+1}`;
            modal.querySelector('#step-velocity').value = firstNote.velocity;
            modal.querySelector('#step-offset').value = firstNote.offset;
            modal.querySelector('#step-ratchet').value = firstNote.ratchet || 1;
            modal.querySelector('#step-velocity-display').textContent = firstNote.velocity;
            modal.querySelector('#step-offset-display').textContent = firstNote.offset;
            modal.classList.remove('hidden');
        }

        function handleStepDetailChange() {
            if (!state.activeModalStep) return;
            const { track, step } = state.activeModalStep;
            const stepData = state.stepGrid[track] ?.[step];
            if (!stepData || stepData.length === 0) return;
            const modal = document.getElementById('step-detail-modal');
            const newVelocity = parseInt(modal.querySelector('#step-velocity').value);
            const newOffset = parseInt(modal.querySelector('#step-offset').value);
            const newRatchet = parseInt(modal.querySelector('#step-ratchet').value);
            modal.querySelector('#step-velocity-display').textContent = newVelocity;
            modal.querySelector('#step-offset-display').textContent = newOffset;
            stepData.forEach(note => {
                note.velocity = newVelocity;
                note.offset = newOffset;
                note.ratchet = newRatchet;
            });
        }

        function renderMidiSettings() {
            const container = document.getElementById('midi-track-settings');
            if (!container) return;
            const header = `<div class="hidden md:grid grid-cols-5 gap-x-4 gap-y-2 text-sm font-bold text-gray-400 border-b border-gray-600 pb-2 mb-2">
                <span>Track</span><span>Input Device</span><span>In Ch</span><span>Output Device</span><span>Out Ch</span>
            </div>`;
            const inputOptions = `<option value="none">None</option>` + state.midi.inputs.map(i => `<option value="${i.id}">${i.name}</option>`).join('');
            const outputOptions = `<option value="none">None</option>` + state.midi.outputs.map(o => `<option value="${o.id}">${o.name}</option>`).join('');
            const channels = Array.from({ length: 16 }, (_, i) => `<option value="${i+1}">${i+1}</option>`).join('');
            
            const trackRows = state.tracks.map((track, index) => `
                <div class="space-y-2 md:space-y-0 md:grid md:grid-cols-5 md:gap-x-4 items-center border-b border-gray-700 py-2">
                    <div class="font-medium text-gray-300 truncate"><span class="md:hidden font-bold text-gray-400">Track: </span>${track.name}</div>
                     <div><label for="midi-in-port-${index}" class="text-sm font-medium text-gray-400 md:hidden">Input Device</label><select id="midi-in-port-${index}" data-track-index="${index}" data-type="in-port" class="midi-config-select w-full bg-gray-600 rounded p-1 text-sm mt-1 md:mt-0">${inputOptions}</select></div>
                    <div><label for="midi-in-chan-${index}" class="text-sm font-medium text-gray-400 md:hidden">Input Channel</label><select id="midi-in-chan-${index}" data-track-index="${index}" data-type="in-chan" class="midi-config-select w-full bg-gray-600 rounded p-1 text-sm mt-1 md:mt-0"><option value="all">All</option>${channels}</select></div>
                    <div><label for="midi-out-port-${index}" class="text-sm font-medium text-gray-400 md:hidden">Output Device</label><select id="midi-out-port-${index}" data-track-index="${index}" data-type="out-port" class="midi-config-select w-full bg-gray-600 rounded p-1 text-sm mt-1 md:mt-0">${outputOptions}</select></div>
                    <div><label for="midi-out-chan-${index}" class="text-sm font-medium text-gray-400 md:hidden">Output Channel</label><select id="midi-out-chan-${index}" data-track-index="${index}" data-type="out-chan" class="midi-config-select w-full bg-gray-600 rounded p-1 text-sm mt-1 md:mt-0">${channels}</select></div>
                </div>
            `).join('');

            container.innerHTML = header + trackRows;
            state.tracks.forEach((track, index) => {
                container.querySelector(`[data-track-index="${index}"][data-type="in-port"]`).value = track.midiInPortId;
                container.querySelector(`[data-track-index="${index}"][data-type="in-chan"]`).value = track.midiInChan;
                container.querySelector(`[data-track-index="${index}"][data-type="out-port"]`).value = track.midiOutPortId;
                container.querySelector(`[data-track-index="${index}"][data-type="out-chan"]`).value = track.midiOutChan;
            });
        }

        // --- EVENT LISTENERS INITIALIZATION ---
        function initializeEventListeners() {
            if (state.listenersInitialized) return;

            dom.playStopBtn.addEventListener('click', () => togglePlayback());
            dom.tempoSlider.addEventListener('input', e => { 
                if (state.midi.clockSourceId === 'internal') {
                    Tone.Transport.bpm.value = e.target.value; 
                    dom.tempoDisplay.textContent = e.target.value;
                }
            });
            dom.addTrackBtn.addEventListener('click', addTrack);
            dom.removeTrackBtn.addEventListener('click', removeLastTrack);
            dom.midiSettingsBtn.addEventListener('click', () => {
                renderMidiSettings();
                document.getElementById('midi-modal')?.classList.remove('hidden');
            });
            dom.clockSourceSelect.addEventListener('change', handleClockSourceChange);
            
            dom.noteInputGrid.addEventListener('mousedown', e => {
                if (e.target.matches('.note-input-btn')) {
                    e.preventDefault();
                    handleNoteOn(e.target.dataset.note);
                    state.lastPressedNote = e.target.dataset.note;
                }
            });
            window.addEventListener('mouseup', () => handleNoteOff(state.lastPressedNote));
            window.addEventListener('mouseleave', () => handleNoteOff(state.lastPressedNote));

            dom.gridContainer.addEventListener('click', e => {
                const target = e.target;
                const action = target.dataset.action;
                if (!action) return;
                
                const trackRow = target.closest('.track-row');
                if (!trackRow) return;
                const trackIndex = parseInt(trackRow.dataset.trackIndex);

                switch (action) {
                    case 'select-track': selectTrack(trackIndex); break;
                    case 'arm-track': armTrack(trackIndex); break;
                    case 'toggle-mute': toggleMute(trackIndex); break;
                    case 'toggle-solo': toggleSolo(trackIndex); break;
                    case 'open-track-settings': openTrackSettingsModal(trackIndex); break;
                    case 'load-sample': trackRow.querySelector('[data-action="load-sample-input"]').click(); break;
                    case 'clear-sample': clearSample(trackIndex); break;
                    case 'handle-step-click':
                        const stepIndex = parseInt(target.dataset.step);
                        handleStepClick(trackIndex, stepIndex, e);
                        break;
                    case 'playhead-left':
                        if (state.armedTrackIndex > -1 && !state.isPlaying) {
                            state.nonPlayStepIndices[state.armedTrackIndex] = (state.nonPlayStepIndices[state.armedTrackIndex] - 1 + NUM_STEPS) % NUM_STEPS;
                            updateNextRecordStepVisual();
                        }
                        break;
                    case 'playhead-right':
                        if (state.armedTrackIndex > -1 && !state.isPlaying) {
                            state.nonPlayStepIndices[state.armedTrackIndex] = (state.nonPlayStepIndices[state.armedTrackIndex] + 1) % NUM_STEPS;
                            updateNextRecordStepVisual();
                        }
                        break;
                }
            });
             dom.gridContainer.addEventListener('dblclick', e => {
                const target = e.target;
                if(target.dataset.dblaction === 'open-step-detail') {
                     const trackRow = target.closest('.track-row');
                     const trackIndex = parseInt(trackRow.dataset.trackIndex);
                     const stepIndex = parseInt(target.dataset.step);
                     openStepDetailModal(trackIndex, stepIndex);
                }
            });
            dom.gridContainer.addEventListener('change', e => {
                const target = e.target;
                if (target.dataset.action === 'load-sample-input') {
                    const trackRow = target.closest('.track-row');
                    if (!trackRow) return;
                    const trackIndex = parseInt(trackRow.dataset.trackIndex);
                    loadSample(e, trackIndex);
                }
            });

            dom.modalsContainer.addEventListener('click', e => {
                const el = e.target;
                if (el.matches('.close-modal-btn')) el.closest('.modal').classList.add('hidden');
                else if (el.closest('#track-settings-modal') && el.matches('button')) handleTrackSettingsChange(e);
            });
            dom.modalsContainer.addEventListener('input', e => {
                const modal = e.target.closest('.modal');
                if (!modal) return;
                if (modal.id === 'step-detail-modal' || modal.id === 'track-settings-modal') handleTrackSettingsChange(e);
            });
            dom.modalsContainer.addEventListener('change', e => {
                 if (e.target.matches('.midi-config-select')) {
                    const { trackIndex, type } = e.target.dataset;
                    const track = state.tracks[parseInt(trackIndex)];
                    if(!track) return;
                    switch (type) {
                        case 'in-port': track.midiInPortId = e.target.value; break;
                        case 'in-chan': track.midiInChan = e.target.value; break;
                        case 'out-port': track.midiOutPortId = e.target.value; break;
                        case 'out-chan': track.midiOutChan = e.target.value; break;
                    }
                } else if(e.target.matches('#synth-algorithm') || (e.target.matches('.instrument-control') && e.target.dataset.param === 'type')) {
                    handleTrackSettingsChange(e);
                }
            });
            
            state.listenersInitialized = true;
        }

        // --- STARTUP ---
        function main() {
            for (let i = 0; i < 4; i++) {
                state.tracks.push(createNewTrack(i));
                state.stepGrid.push(Array.from({ length: 32 }, () => [])); // Initialize with max steps
                state.nonPlayStepIndices.push(0);
            }
            renderAll();
            initializeEventListeners();
            initializeMidi();
        }
        
        main();
    </script>
</body>
</html>
